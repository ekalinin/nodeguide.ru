========================================
RESTful методы и тестирование в Expresso
========================================

Добро пожаловать в третью часть руководства по созданию веб-приложения
с помощью **Node.js**. В рамках серии уроков будет рассказано про основные
особенности и трудности, которые возникают при работе с Node.js.

Предыдущие части:

- :doc:`node-tutorial-1`
- :doc:`node-tutorial-2`, коммит: `4ea936b`_

.. _4ea936b: https://github.com/alexyoung/nodepad/tree/4ea936b4b426012528fc722c7576391b48d5a0b7

В этой части мы будем опираться на тот код, который был сгенерирован в
предыдущей части. В приложение был добавлен каркас модели ``Document``,
так что пора добавить ей немного содержания. Далее будет предполагаться,
что исходый код скачан из git-репозитория, так что самое время посетить
notepad_ и скачать код.

.. _notepad: https://github.com/alexyoung/nodepad

Логирование
===========

Для начала давайте добавим немного логирования. Express предоставляет
такую возможность в блоке ``app.configure``. Просто убедитесь, что Вы
используете логирование:

.. code-block:: javascript

    app.configure(function() {
      app.use(express.logger());
      // Далее идут опции, добавленные в прошлой части
    });

Хорошим тоном считается немного различающаяся конфигурация логирования
в зависимости от окружения. Так я и поступил:

.. code-block:: javascript

    app.configure('development', function() {
      app.use(express.logger());
      app.use(express.errorHandler({
          dumpExceptions: true,
          showStack: true
      }));
    });

    app.configure('production', function() {
      app.use(express.logger());
      app.use(express.errorHandler()); 
    });

API
===

Доступ к документам можно организовать по HTTP, используя CRUD-подобное
(Create, Read, Update, Delete) RESTful API:

- ``GET /documents`` - возвращает список документов
- ``POST /documents/`` - создает новый документ
- ``GET /documents/:id`` - возвращает конкретный документ
- ``PUT /documents/:id`` - изменяет конкретный документ
- ``DELETE /documents/:id`` - удалет конкретный документ

HTTP-метод очень важен. Обратите внимание, что список документов и создание
нового документа имеют один и тот же URL, а результат зависит от того,
какой HTTP-метод используется (``PUT`` или ``GET``). Express корректно
обработает каждый из этих URL и выполнить для каждого из них нужный код.

HTTP-метод имеет значение
=========================

Если Вы до сих пор не использовали в своей работе данный подход, то
просто запомните - HTTP-метод имеет значение. Так, например, в прошлой
части руководства мы определили следующий метод:

.. code-block:: javascript

    app.get('/', function(req, res) {
      // Ответ на GET для '/'
      // ...
    });

Если Вы создадите форму, которая будет выполнять POST для того же URL,
то Express будет возвращать ошибку, так как не задан соответствующий
обработчик.

Так же напомню, что в прошлой части мы добавили в конфигурацию настройку
``express.methodOverride``. Причиной этому является тот факт, что мы не
можем полагаться на браузер в вопросах определения HTTP-методов (например,
таких как ``DELETE``). Но мы можем использовать некоторое соглашение,
чтобы обойти эту проблему: формы могут использовать скрытые поля, которые
Express будет интерпретировать как "настоящий" HTTP-метод.

Иногда этот подход к RESTful HTTP API может показаться неизящным, но
плюсом данного соглашения является огромное количество веб-приложений,
которые успешно используют REST.

Справочник CRUD заглушек
========================

Вот как должны выглядеть CRUD заглушки:

.. code-block:: javascript

    // Список
    app.get('/documents.:format', function(req, res) {
    });

    // Создать
    app.post('/documents.:format?', function(req, res) {
    });

    // Прочитать
    app.get('/documents/:id.:format?', function(req, res) {
    });

    // Изменить
    app.put('/documents/:id.:format?', function(req, res) {
    });

    // Удалить
    app.del('/documents/:id.:format?', function(req, res) {
    });

Обратите внимание, что Express использует ``del`` вместо *delete*.

Асинхронные базы данных
=======================

Перед тем как мы начнем реализовывать каждый REST метод, давайте
посмотрим на пример - загрузка списка документов. Вы, вероятно,
привыкли работать в следующей манере:

.. code-block:: javascript

    app.get('/documents', function(req, res) {
      var documents = Document.find().all();

      // Отправляем результат как JSON
      res.send(documents);
    }

В Node.js в основном используют библиотеки базы данных асинхронно.
Это означает, что нам необходимо сделать так:

.. code-block:: javascript

    app.get('/documents', function(req, res) {
      Document.find().all(function(documents) {
        // 'documents' будет содержать все документы,
        // возвращенные запросом
        res.send(documents.map(function(d) {
          // Возвращаем объект в более полезном виде,
          // который res.send() сможет отправить во вне как JSON
          return d.__doc;
        }));
      });
    });

Разница заключается в функции обратного вызова (callback), используемой
для доступа к результату. Этот пример не очень эффективный, так как
в нем каждый документ добавляется в массив. Вероятно, было бы более
правильно возвращать их в виде потока клиенту, как только они станут
доступными.

Форматы
=======

Я предпочитаю поддерживать HTML и JSON где это необходимо. Для этого
может быть использован следующий подход:

.. code-block:: javascript

    // :format может быть json или html
    app.get('/documents.:format?', function(req, res) {
      // Подобие Mongo запроса
      Document.find().all(function(documents) {
        switch (req.params.format) {
          // Для json генерируем подходящие данные
          case 'json':
            res.send(documents.map(function(d) {
              return d.__doc;
            }));
          break;

          // Иначе - отрисовываем html-шаблон
          // (пока еще не реализовано)
          default:
            res.render('documents/index.jade');
        }
      });
    });

Этот пример демонстрирует работу одной из функциональностей ядра
Express/Connect: строка, описыващая маршрутизацию, использует ``:format``
для того, чтобы определить, какой тип данных ожидает клиент: JSON или
HTML. Знак вопроса означает, что формат может быть не задан явно.

Обратите внимание, что этот пример оборачивает операции в базе данных
кодом для ответа клиенту. Такой подход можно использовать для удаления
или изменения объектов.

Переадресация
=============

В зависимости от того, какой формат задан, метод создания документа
возвращает либо JSON версию документа, либо выполняет переадресацию,
если запрошен HTML:

.. code-block:: javascript

    app.post('/documents.:format?', function(req, res) {
      var document = new Document(req.body['document']);
      document.save(function() {
        switch (req.params.format) {
          case 'json':
            res.send(document.__doc);
           break;

           default:
            res.redirect('/documents');
        }
      });
    });

В примере используется метод ``res.redirect`` для перенаправления браузера
к списку документов. Точно так же можно можно перенаправлять на форму
редактирования. Мы по-ближе познакомимся с этой возможностью, когда будем
реализовывать интерфейс пользователя.

Тесты
=====

Приложения подобные нашему, я обычно, начинаю писать с тестов для API.
Таким образом гораздо проще реализовать большинство методов перед тем,
как погружаться в код пользовательского интерфейса. Первым делом, необходимо
добавить описание содинения к тестовой базе данных:

.. code-block:: javascript

    app.configure('test', function() {
      app.use(express.errorHandler({
        dumpExceptions: true,
        showStack: true
      }));
      db = mongoose.connect('mongodb://localhost/nodepad-test');
    });

После чего в ``test/app.test.js`` я явно прописываю использование тестового
окружения:

.. code-block:: javascript

    process.env.NODE_ENV = 'test';

Это означает, что тестовая база данных может быть безболезненно захламлена
тестовыми данными или даже удалена.

Сами тесты требуют немного времени, чтобы начать ими пользоваться. Тесты
Expresso_ замечательно работают для тестирования Express приложений, но
выяснение тонкостей работы требуют чтения значительного объекма исходного
кода и списков рассылки.

.. _Expresso: http://visionmedia.github.com/expresso/

Вот показательный пример:

.. code-block:: javascript

    'POST /documents.json': function(assert) {
      assert.response(app, {
          url: '/documents.json',
          method: 'POST',
          data: JSON.stringify({ document: { title: 'Test' } }),
          headers: { 'Content-Type': 'application/json' }
        }, {
          status: 200,
          headers: { 'Content-Type': 'application/json' }
        },

        function(res) {
          var document = JSON.parse(res.body);
          assert.equal('Test', document.title);
        });
    }

Названием теста ('POST /documents.json') может быть все, что угодно.
Заголовок не анализируется. В первом параметре определяется HTTP-запрос.
В данном случае, я указал заголовок ``Content-Type``. Если этого не будет
сделано, то Connect не сможет проанализировать ``data``.

Я специально написал тесты для JSON и ``application/x-www-form-urlencoded``,
так как обычно именно на этих вещах происходит затык. Просто запомните, что
Express "из коробки" не умеет работать с зашифрованными данными форм и
именно поэтому мы указали ``methodOverride`` в блоке конфигурации.

С полными примерами тестов можно ознакомиться в данном `коммите 39e66cb`_.

.. _коммите 39e66cb: https://github.com/alexyoung/nodepad/commit/39e66cb9d11a67044495beb0de1934ac4d9c4786

Заключение
==========

Теперь вы должны уметь:

- создавать CRUD-заглушки, указывая необходимый HTTP-метод, в Express
- организовывать код приложения таким образом, чтобы можно было тестировать
  используя Express, Expresso и Mongoose
- реализовывать простые Expresso тесты

В следующей части мы закончим с API для документов и начнем добавлять
основные HTML шаблоны. Я собираюсь добавить интерфейс на основе jQuery,
но будет лучше, если мы сначала закончим с тестами и API.

Ссылки
======

- `Документация по Node API <http://nodejs.org/api.html>`_
- `Документация по Mongoose <http://labs.learnboost.com/mongoose/>`_
- `Руководство по Express <http://expressjs.com/guide.html>`_
- `Документация по Expresso <http://visionmedia.github.com/expresso/>`_
- `Разъяснения от TJ по Content-Type для тестов <http://groups.google.com/group/express-js/msg/d6e3462934f4086d>`_
